#!/usr/bin/env python3
# from tkinter import *
import subprocess, pathlib, shlex
import threading
import queue
import time
import os
import sys
import getConfig 
from math import tan
from math import pi
DEBUG = 0 # variable to enable debug mode
TYPE = [] # types that are printed

TOUCHPAD_CALIBRATION = 1 # scaling down for touchpad movements
TOUCHSCREEN_CALIBRATION = 2 # scaling down for touchscreen movements

DECISION = 350 # sufficient movement to make decision on direction
PINCH_DECISION = 160 #seems like x_cum and y_cum should got to around 0 if fingers moved symmetrically in or out  #sufficient momvent to make pinch

ANGLE_X = 21 # angle to interpret as horizontal
ANGLE_Y = 21 # angle to interpret as vertical

DEBOUNCE = 0.02  #sleep for 10 ms(now 40 ms), fastest tap around 25 ms, gotten from new_touch, touchpad data. in practice works well.
THRESHOLD_SQUARED = 150 # threshold to be considered a move, squared sum of x and y
PINCH_THRESHOLD = 100

REP_THRES = 0.2 #need to break this TIME before REP engage
REP = 350 # for 3 finger stuff (depreciated)
REP_3 = 150 # for 3 finger stuff
REP_4x= 150 # for 4 finger x, was having issue with horizontal swipes overstepping but vertical ones being predictable
REP_4 = 150 # for 4 finger stuff; repeat after this much x,y movement
PINCH_REP = 40

DEADZONE_SQUARED = 1000 # deadzone where up until this, pinches aren't interpreted
all_gestures = getConfig.get_conf(os.path.expanduser("~/.config/gestures.conf"))


def try_or_set(expression, val, gestures=False):
    try:
        return eval(expression);
    except Exception:
        return val; 

def print(*s):
    """redefine print to print only when debug is on."""
    if (DEBUG and (s[-1] in TYPE or not TYPE)):
        __builtins__.print(s)

# generic gesture worker
class Worker(threading.Thread):

    """ A worker thread that takes directory names from a queue, finds all
        files in them recursively and reports the result.

        Input is done by placing directory names (as strings) into the
        Queue passed in dir_q.

        Output is done by placing tuples into the Queue passed in result_q.
        Each tuple is (thread name, dirname, [list of files]).

        Ask the thread to stop by calling its join() method.
    """
    def __init__(self, q, gestures):
        super(Worker, self).__init__()
        self.q = q
        self.status = {} #slots :   {"x" :x , "y" : y}
        self.status_dis = 0
        self.debounce = 0
        self.gestures = gestures
        self.gesture_queue = []
        self.rep_start = 0
        self.last_command_is_gesture_end = False
        self.pinch_deadzone_enabled = try_or_set("all_gestures[\"pinch_deadzone_enabled\"] == \"True\" ",True)
        self.pinch_deadzone_enabled = try_or_set("gestures[\"pinch_deadzone_enabled\"] == \"True\" ", self.pinch_deadzone_enabled, gestures=gestures)
        print(f"Pinch deadzone is enabled: {self.pinch_deadzone_enabled}.")
        self.gesture = {"type": "", "total": {"x-cum": 0, "y-cum": 0, "moved": 0, "dis-cum": 0} , "slots" : {}} # keys: type, moved, slot (1-9), total ; slot and total keys: x-cum, y-cum, moved, dis-cum

    def run(self):
        # As long as we weren't asked to stop, try to take new tasks from the
        # queue. The tasks are taken with a blocking 'get', so no CPU
        # cycles are wasted while waiting.
        # Also, 'get' is given a timeout, so stoprequest is always checked,
        # even if there's nothing in the queue.
        while True:
            # get messages(dequeue from message queue) and do approperate action
            event = self.q.get(True)
            print("")
            print("Worker")
            print(f"def: {event}")
            print("")
            if event["type"] == "finger_start":
                #print("finger_start")

                self.finger_start(event);
            if event["type"] == "finger_update":
                #print("finger_update")
                #print(event)
                self.finger_update(event);
            if event["type"] == "finger_remove":
                #print("finger_remove")
                self.finger_remove(event);

            # dequeue from gesture queue and execute after debounce times out
            if(len(self.gesture_queue) != 0 and float(event["time"]) - self.debounce >= DEBOUNCE):
                #print("executing")
                #print(self.gesture_queue)
                for gesture in self.gesture_queue:
                    #print(gesture)
                    try:
                        if(gesture and "stop" not in TYPE):
                            subprocess.call(gesture);
                    except: 
                        print("error with:")
                        print("gesture = ", gesture)
                        print("gesture queue = ", self.gesture_queue)
                        print("gesture information = ", self.gesture)


                self.gesture_queue = [];



    def finger_start(self, event):
        """ append new finger to gesture.
        """
        # end gesture
        #self.gesture_end(event["time"]);
        ## restart debounce
        #print("here")
        self.last_command_is_gesture_end = False;
        self.debounce = float(event["time"]);

        ## restart gesture params
        slots = self.gesture["slots"];
        self.gesture = {"type": "", "total": {"x-cum": 0, "y-cum": 0, "moved" : 0, "dis-cum": 0},  "slots" : {} } # keys: type, moved, slot (1-9), total ; slot and total keys: x-cum, y-cum
        for key in slots:
            self.gesture["slots"][key] = {"x-cum": 0, "y-cum": 0, "moved": 0};

        #  initiate state for finger
        slot = event["slot"];

        self.gesture["slots"][slot] = {};
        self.gesture["slots"][slot]["x-cum"] = 0
        #self.gesture["slots"][slot]["x-diff"] = 0
        #self.gesture["slots"][slot]["x"] = self.status[slot]["x"];

        self.gesture["slots"][slot]["y-cum"] = 0
        #self.gesture["slots"][slot]["y-diff"] = 0
        #self.gesture["slots"][slot]["y"] = self.status[slot]["y"];

        self.gesture["slots"][slot]["moved"] = 0

        self.update_status(slot, event[slot], 0); #need to wait until status updated before calcing max_dis
        max_dis =  self.max_distance();
        self.status_dis =  max_dis;
        #print(max_dis)
        #print(self.status);


    def finger_update(self, event):
        """ Update started gesture
        """
        # update state for updated finger
        self.last_command_is_gesture_end = False;
        slot = event["slot"];

        # gesture must be updated before status because need to capture difference between last and now
        self.gesture["slots"][slot]["x-cum"] +=  event[slot]["x"] - self.status[slot]["x"]
        #self.gesture["slots"][slot]["x-diff"] = event[slot]["x"] - self.status[slot]["x"]
        #self.gesture["slots"][slot]["x"] = self.status[slot]["x"];

        self.gesture["slots"][slot]["y-cum"] += event[slot]["y"] - self.status[slot]["y"]
        #self.gesture["slots"][slot]["y-diff"] = event[slot]["y"] - self.status[slot]["y"]
        #self.gesture["slots"][slot]["y"] = self.status[slot]["y"];

        self.gesture["total"]["x-cum"] += event[slot]["x"] - self.status[slot]["x"]
        self.gesture["total"]["y-cum"] += event[slot]["y"] - self.status[slot]["y"]

        max_dis =  self.max_distance();
        #print(max_dis);
        #print(self.status_dis);
        self.gesture["total"]["dis-cum"] += max_dis - self.status_dis;


        self.update_status(slot, event[slot],max_dis);

        #print(self.gesture["total"]);
        print(self.gesture);

        # pick which type of guesture is currenlty executing after all fingures have been verified
        no_slots = len(self.gesture["slots"]);
        if (not self.gesture["slots"][slot]["moved"]):
            self.gesture["slots"][slot]["moved"] = self.gesture["slots"][slot]["y-cum"] ** 2 + self.gesture["slots"][slot]["x-cum"] ** 2 > THRESHOLD_SQUARED
            self.gesture["total"]["moved"] += self.gesture["slots"][slot]["moved"];

        elif (not self.gesture["type"]):
            # pinch
            if(self.gesture["total"]["moved"] >= 1):# move out the pinch gesture sutff so that can do gestures when only one finger is moving
                x_cum = abs(self.gesture["total"]["x-cum"]);
                y_cum = abs(self.gesture["total"]["y-cum"]);
                dis_cum =  self.gesture["total"]["dis-cum"];

                #if (x_cum + y_cum > PINCH_DECISION):
                if(no_slots == 2):
                    print(f"dis_cum = {dis_cum}")
                    print(f"x_cum + y_cum = {x_cum + y_cum}")
                    print(f"x_cum = {x_cum}")
                    print(f"y_cum = {y_cum}")
                    if(x_cum + y_cum > PINCH_DECISION): #small hack to stop pinch from interspeting scrolling
                        self.gesture["type"] = "no_gesture";
                    elif(abs(dis_cum) > PINCH_THRESHOLD and 
                        ((not self.pinch_deadzone_enabled) or self.out_of_deadzone())): # added deadzone 
                        if(dis_cum > 0): #pinch in
                            self.gesture["type"] += "pinch_i";
                            self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["pinch"]['2']['i']['start']));
                        else: #pinch out
                            self.gesture["type"] += "pinch_o";
                            self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["pinch"]['2']['o']['start']));
                        self.rep_start = float(event["time"]);

            # swipe            
            if(no_slots == self.gesture["total"]["moved"]):
                x_cum = abs(self.gesture["total"]["x-cum"]);
                y_cum = abs(self.gesture["total"]["y-cum"]);
                dis_cum =  self.gesture["total"]["dis-cum"];
                if (x_cum + y_cum > DECISION):
                    if(no_slots == 3):
                        print(f"x_cum = {x_cum}", "angle")
                        print(f"y_cum = {y_cum}", "angle")
                        print(f"horz {y_cum} <= {x_cum * tan(ANGLE_X * pi/180)}", "angle")
                        print(f"vert {y_cum} >= {x_cum * tan((90 - ANGLE_Y) * pi/180)}", "angle")
                        if(y_cum <= x_cum * tan((ANGLE_X) * pi/180) ):
                            self.gesture["type"] = "swipe_horizontal";
                            self.rep_start = float(event["time"]);
                            #print(self.gestures["swipe"]['3']['l']['start']);
                            if(self.gesture["total"]["x-cum"] <= 0) :
                                # self.gesture["type"] = "swipe_l";
                                self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['l']['start']));
                            else :
                                # self.gesture["type"] = "swipe_r";
                                self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['r']['start']));
                        elif (y_cum >= x_cum * tan((90 - ANGLE_Y) * pi/180)):
                            self.gesture["type"] = "swipe_vertical";
                            if(self.gesture["total"]["y-cum"] <= 0) :
                                # self.gesture["type"] = "swipe_u";
                                self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['u']['start']));
                            else :
                                # self.gesture["type"] = "swipe_d";
                                self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['d']['start']));
                        else: # (y_cum > x_cum * tan((90 - ANGLE_Y) * pi/180) and y_cum < x_cum * tan((ANGLE + CLEARANCE) * pi/180)):
                            x_cum = self.gesture["total"]["x-cum"];
                            y_cum = self.gesture["total"]["y-cum"];
                            if(x_cum * y_cum > 0): #left up, right down
                                self.gesture["type"] = "swipe_diagonal_\\";   
                                if(x_cum <= 0 and y_cum < 0): #left up 
                                    # self.gesture["type"] = "swipe_lu";
                                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['lu']['start']));

                                if(x_cum > 0 and y_cum >= 0): #right down
                                    # self.gesture["type"] = "swipe_rd";
                                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['rd']['start']));

                            if(x_cum * y_cum < 0): #right up
                                self.gesture["type"] = "swipe_diagonal_//";   
                                if(x_cum >= 0 and y_cum < 0): #right up
                                    # self.gesture["type"] = "swipe_lu";
                                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['ru']['start']));

                                if(x_cum < 0 and y_cum >= 0): #left down
                                    # self.gesture["type"] = "swipe_ld";
                                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['ld']['start']));
                                
                                self.rep_start = float(event["time"]);
                    if(no_slots == 4):
                        if(y_cum <= x_cum * tan((ANGLE_X) * pi/180) or y_cum > x_cum * tan((90 - ANGLE_Y) * pi/180) ):
                            self.gesture["type"] = "swipe_horizontal_vertical";
                            if (x_cum > y_cum):
                                if (self.gesture["total"]["x-cum"] >= 0):
                                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['r']['start']));
                                else:
                                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['l']['start']));
                            else:
                                if (self.gesture["total"]["y-cum"] >= 0):
                                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['d']['start']));
                                else:
                                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['u']['start']));
                            self.rep_start = float(event["time"]);
                        else:#(y_cum > x_cum * tan((90 - ANGLE - CLEARANCE) * pi/180) and y_cum < x_cum * tan((ANGLE + CLEARANCE) * pi/180)):
                            x_cum = self.gesture["total"]["x-cum"];
                            y_cum = self.gesture["total"]["y-cum"];
                            if(x_cum * y_cum > 0): #left up, right down
                                self.gesture["type"] = "swipe_diagonal_\\";
                                if(x_cum <= 0 and y_cum < 0): #left up 
                                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['lu']['start']));

                                if(x_cum > 0 and y_cum >= 0): #right down
                                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['rd']['start']));

                            if(x_cum * y_cum < 0): #right up
                                self.gesture["type"] = "swipe_diagonal_//";
                                if(x_cum >= 0 and y_cum < 0): #right up
                                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['ru']['start']));

                                if(x_cum < 0 and y_cum >= 0): #left down
                                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['ld']['start']));

                                self.rep_start = float(event["time"]);

                    if(no_slots == 5):
                        if(y_cum <= x_cum * tan((ANGLE_X) * pi/180) ):
                            self.gesture["type"] = "swipe_horizontal";
                        elif (y_cum > x_cum * tan((90 - ANGLE_Y) * pi/180)):
                            self.gesture["type"] = "swipe_vertical";
                        else:#(y_cum > x_cum * tan((90 - ANGLE - CLEARANCE) * pi/180) and y_cum < x_cum * tan((ANGLE + CLEARANCE) * pi/180)):
                            self.gesture["type"] = "swipe_diagonal";

                    # reset because don't want to trigger again in
                    if(self.gesture["type"]):
                        self.gesture["total"]["x-cum"] = 0;
                        self.gesture["total"]["y-cum"] = 0;
                        self.gesture["total"]["dis-cum"] = 0;
        # inqueue gesture to run
        else:
            if(float(event["time"]) - self.rep_start < REP_THRES): # to remove extra movement caused by movement before RE_THRES has been crossed
                self.gesture["total"]["x-cum"] = 0;
                self.gesture["total"]["y-cum"] = 0;
                self.gesture["total"]["dis-cum"] = 0;
            else:
                dis_cum =  self.gesture["total"]["dis-cum"];
                if(no_slots == 2):
                    if(self.gesture["type"] == "pinch_i"):
                       if(abs(dis_cum) > PINCH_REP):
                           if(dis_cum > 0): #pinch in
                               self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["pinch"]['2']['i']['update']['i']));
                           else: #pinch out
                               self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["pinch"]['2']['i']['update']['o']));

                           self.gesture["total"]["dis-cum"] = 0;
                    if(self.gesture["type"] == "pinch_o"):
                       if(abs(dis_cum) > PINCH_REP):
                           if(dis_cum > 0): #pinch in
                               self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["pinch"]['2']['o']['update']['i']));
                           else: #pinch out
                               self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["pinch"]['2']['o']['update']['o']));
                           self.gesture["total"]["dis-cum"] = 0;



                if(no_slots == 3):
                    if(self.gesture["type"] == "swipe_horizontal"):
                        # better to zero out after a gesture is triggered
                        if(self.gesture["total"]["x-cum"] >= REP_3):
                            self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['l']['update']['r']));
                            # self.gesture_queue.append("evemu_do RIGHT".split());
                            #self.gesture["total"]["x-cum"] -= REP; #better to zero out
                            self.gesture["total"]["x-cum"] = 0
                        if(self.gesture["total"]["x-cum"] <= -REP_3):
                            self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['l']['update']['l']));
                            # self.gesture_queue.append("evemu_do LEFT".split());
                            #self.gesture["total"]["x-cum"] += REP;
                            self.gesture["total"]["x-cum"] = 0;

                        # y is measured positive when moving down the touchpad
                        if(self.gesture["total"]["y-cum"] >= REP_3):
                            self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['l']['update']['d']));
                            # self.gesture_queue.append("evemu_do DOWN".split());
                            #self.gesture["total"]["y-cum"] -= REP;
                            self.gesture["total"]["y-cum"] = 0;
                        if(self.gesture["total"]["y-cum"] <= -REP_3):
                            self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['l']['update']['u']));
                            # self.gesture_queue.append("evemu_do UP".split());
                            #self.gesture["total"]["y-cum"] += REP;
                            self.gesture["total"]["y-cum"] = 0;

                    if(self.gesture["type"] == "swipe_diagonal_//"):
                        if(self.gesture["total"]["x-cum"] -  self.gesture["total"]["y-cum"] >= REP):
                            self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['ld']['update']['ru']));
                            # self.gesture_queue.append("evemu_do Page_Down".split());
                            self.gesture["total"]["x-cum"] = 0; #better to zero out
                            self.gesture["total"]["y-cum"] = 0;

                        if(self.gesture["total"]["x-cum"] - self.gesture["total"]["y-cum"]  <=  -REP):
                            self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['ld']['update']['ld']));
                            # self.gesture_queue.append("evemu_do Page_Up".split());
                            self.gesture["total"]["x-cum"] = 0; #better to zero out
                            self.gesture["total"]["y-cum"] = 0;
                            #self.gesture["total"]["y-cum"] = 0;

                if(no_slots == 4):
                    if(self.gesture["type"] == "swipe_horizontal_vertical"):
                        # better to zero out after a gesture is triggered
                        if(self.gesture["total"]["x-cum"] >= REP_4x):
                            self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['l']['update']['r']));
                            # self.gesture_queue.append("evemu_do Right".split());
                            #self.gesture["total"]["x-cum"] -= REP; #better to zero out
                            self.gesture["total"]["x-cum"] = 0;
                            self.gesture["total"]["y-cum"] = 0;

                        if(self.gesture["total"]["x-cum"] <= -REP_4x):
                            self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['l']['update']['l']));
                            # self.gesture_queue.append("evemu_do Left".split());
                            # self.gesture["total"]["x-cum"] += REP;
                            self.gesture["total"]["x-cum"] = 0;
                            self.gesture["total"]["y-cum"] = 0;

                        # y is messured postive when moving down the touchpad
                        if(self.gesture["total"]["y-cum"] >= REP_4):
                            self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['l']['update']['d']));
                            # self.gesture_queue.append("evemu_do Down".split());
                            #self.gesture["total"]["y-cum"] -= REP;
                            self.gesture["total"]["y-cum"] = 0;
                            self.gesture["total"]["x-cum"] = 0;

                        if(self.gesture["total"]["y-cum"] <= -REP_4):
                            self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['l']['update']['u']));
                            # self.gesture_queue.append("evemu_do Up".split());
                            #self.gesture["total"]["y-cum"] += REP;
                            self.gesture["total"]["y-cum"] = 0;
                            self.gesture["total"]["x-cum"] = 0;

                    if(self.gesture["type"] == "swipe_diagonal_//"):
                        if(self.gesture["total"]["x-cum"] -  self.gesture["total"]["y-cum"] >= REP):
                            self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['ld']['update']['ru']));
                            # self.gesture_queue.append("evemu_do Right".split());
                            self.gesture["total"]["x-cum"] = 0; #better to zero out
                            self.gesture["total"]["y-cum"] = 0;

                        if(self.gesture["total"]["x-cum"] - self.gesture["total"]["y-cum"]  <=  -REP):
                            self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['ld']['update']['ld']));
                            # self.gesture_queue.append("evemu_do Left".split());
                            self.gesture["total"]["x-cum"] = 0; #better to zero out
                            self.gesture["total"]["y-cum"] = 0;
                            #self.gesture["total"]["y-cum"] = 0;

        #print(self.gesture_queue)
        #print(self.gesture)


    def gesture_end(self, clock):
        """ end started gesture and reset gesture.
        """
        # signify end of a started gesture
        self.gesture_queue = [];
        x_cum = self.gesture["total"]["x-cum"];
        y_cum = self.gesture["total"]["y-cum"];
        no_slots = len(self.gesture["slots"]);
        print("")
        print("Worker")
        print(self.gesture);
        print(f"float(clock) - self.debounce >= DEBOUNCE : {float(clock)} - {self.debounce} >= {DEBOUNCE} : {float(clock) - self.debounce >= DEBOUNCE} ");
        print("")
        if (float(clock) - self.debounce >= DEBOUNCE):
            if(no_slots == 2):
                if(self.gesture["type"] == "pinch_i"):
                    #print(self.gestures["pinch"]['2']['i']['end']);
                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["pinch"]['2']['i']['end']));
                if(self.gesture["type"] == "pinch_o"):
                    #print(self.gestures["pinch"]['2']['o']['end']);
                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["pinch"]['2']['o']['end']));


            if(no_slots == 3):
                if (not self.gesture["type"]):
                    #print("3 finger tap");
                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['t']));

                elif(self.gesture["type"] == "pinch_i"):
                    #print(self.gestures["pinch"]['3']['i']['end']);
                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["pinch"]['3']['i']['end']));
                elif(self.gesture["type"] == "pinch_o"):
                    #print(self.gestures["pinch"]['3']['o']['end']);
                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["pinch"]['3']['o']['end']));


                elif(self.gesture["type"] == "swipe_horizontal"):
                    #print("end 3 finger swipe_hor")

                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['l']['end']));
                elif (self.gesture["type"] == "swipe_vertical"):
                    #print("swipe_ver")

                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['u']['end']));

                elif(self.gesture["type"] == "swipe_diagonal_\\"):
                    if(x_cum < 0 and y_cum < 0): #left up
                        #print("left up")
                        self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['lu']['end']));
                    if(x_cum >= 0 and y_cum >= 0): #right down
                        self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['rd']['end']));

                elif(self.gesture["type"] == "swipe_diagonal_//"): # issue here if using x-cum and y-cum because they are wiped for interactive (not one-shot) devices
                        self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['3']['ld']['end']));

            if(no_slots == 4):
                if (not self.gesture["type"]):
                    #print("4 finger tap");
                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['t']));


                elif(self.gesture["type"] == "pinch_i"):
                    #print(self.gestures["pinch"]['4']['i']['end']);
                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["pinch"]['4']['i']['end']));
                elif(self.gesture["type"] == "pinch_o"):
                    #print(self.gestures["pinch"]['4']['o']['end']);
                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["pinch"]['4']['o']['end']));


                elif (self.gesture["type"] == "swipe_horizontal_vertical"):
                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['l']['end']));

                elif(self.gesture["type"] == "swipe_diagonal_\\"):
                    if(x_cum < 0 and y_cum < 0): #left up
                        #print("left up")
                        self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['lu']['end']));
                    if(x_cum >= 0 and y_cum >= 0): #right down
                        self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['rd']['end']));

                elif(self.gesture["type"] == "swipe_diagonal_//"): # issue here if using x-cum and y-cum because they are wiped for interactive (not one-shot) devices
                        self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['4']['ld']['end']));

            if(no_slots == 5):
                if (not self.gesture["type"]):
                    #print("5 finger tap");
                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['5']['t']));


                elif(self.gesture["type"] == "pinch_i"):
                    #print(self.gestures["pinch"]['5']['i']['end']);
                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["pinch"]['5']['i']['end']));
                elif(self.gesture["type"] == "pinch_o"):
                    #print(self.gestures["pinch"]['5']['o']['end']);
                    self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["pinch"]['5']['o']['end']));


                elif (self.gesture["type"] == "swipe_horizontal"):
                    #print("end 3 finger swipe_hor")

                    if(x_cum <= 0):
                        self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['5']['l']['end']));
                    else:
                        self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['5']['r']['end']));#'' for "" doesn't work as expected

                elif (self.gesture["type"] == "swipe_vertical"):
                    #print("swipe_ver")
                    if(y_cum <= 0):
                        self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['5']['u']['end']));
                    else:
                        self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['5']['d']['end']));

                elif(self.gesture["type"] == "swipe_diagonal"):
                    if(x_cum < 0 and y_cum < 0): #left up
                        #print("left up")
                        self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['5']['lu']['end']));
                    if(x_cum >= 0 and y_cum >= 0): #right down
                        self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['5']['rd']['end']));

                    if(x_cum < 0 and y_cum >= 0): #left down
                        self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['5']['ld']['end'])); #subprocess.Popen("orientation_swap".split(), cwd=pathlib.Path.home()); #hasn't shown value
                    if(x_cum >= 0 and y_cum < 0): #right up
                        self.gesture_queue.extend(map(lambda x: shlex.split(x), self.gestures["swipe"]['5']['ru']['end'])); #subprocess.Popen("orientation_swap".split(), cwd=pathlib.Path.home()); #hasn't shown value


        for gesture in self.gesture_queue:
            #print(gesture)
            try:
                if(gesture and "stop" not in TYPE):
                    if (no_slots == 5):
                        subprocess.Popen(gesture);
                    else:
                        subprocess.call(gesture);
            except: 
                print("error with:")
                print("gesture = ", gesture)
                print("gesture queue = ", self.gesture_queue)
                print("gesture information = ", self.gesture)

        self.gesture_queue = [];

        # restart debounce
        self.debounce = float(clock);

        # restart gesture params
        slots = self.gesture["slots"];
        self.gesture = {"type": "", "total": {"x-cum": 0, "y-cum": 0, "moved" : 0, "dis-cum": 0}, "slots" : {} } # keys: type, moved, slot (1-9), total ; slot and total keys: x-cum, y-cum
        for key in slots:
            self.gesture["slots"][key] = {"x-cum": 0, "y-cum": 0, "moved": 0};



    def finger_remove(self, event):
        """remove status and gesture of removed finger.
        """

        # execute tap based gesture if any other gesture had not been started
        if not self.last_command_is_gesture_end:
            self.last_command_is_gesture_end = True;
            if(len(self.gesture_queue) == 0 and float(event["time"]) - self.debounce >= DEBOUNCE):
                # do tap gesture according to finger
                pass;
            
            # end gesture
            self.gesture_end(event["time"]);
            
        # update state
        removed_slot = event["removed_slot"];

        if(removed_slot in self.status ): #need this because not updating status when finger added (finger is on touchpad) but after finger starts (both x and y are valid)
            del self.status[removed_slot];
            del self.gesture["slots"][removed_slot];
        
        self.status_dis = self.max_distance();


    def update_status(self, slot, new_state, max_dis):
        self.status[slot] = new_state;
        self.status_dis = max_dis;
        #print(self.status);

    def max_distance(self):
        #return max distance between fingers
        max_dis = 0
        for fin1 in self.status:
            for fin2 in self.status:
                cur_dis = round(((self.status[fin1]["x"] - self.status[fin2]["x"])**2 + (self.status[fin1]["y"] - self.status[fin2]["y"])**2) ** (1/2))
                max_dis = max(max_dis, cur_dis)
        return max_dis;

    def out_of_deadzone(self):
        """check if out of deadzone."""
        are_all_fin_out_of_deadzone = True;
        for fin in self.status:
           fin_move = self.gesture["slots"][fin]["y-cum"] ** 2 + self.gesture["slots"][fin]["x-cum"] ** 2 
           print(fin_move)
           is_fin_out_of_deadzone = fin_move > DEADZONE_SQUARED
           are_all_fin_out_of_deadzone = are_all_fin_out_of_deadzone and is_fin_out_of_deadzone
        return are_all_fin_out_of_deadzone 
# define and start gestures  

# N: Name="ipts 1B96:005E"
# P: Phys=heci3
# S: Sysfs=/devices/pci0000:00/0000:00:16.4/mei::3e8d0870-271a-4208-8eb5-9acb9402ae04:0F/0044:1B96:005E.0007/input/input32
# U: Uniq=
# H: Handlers=mouse4 event26 
# B: PROP=2
# B: EV=1b
# B: KEY=400 0 0 0 0 0
# B: ABS=32f3800000000003
# B: MSC=20
# --
# N: Name="Microsoft Surface Keyboard Touchpad"
# P: Phys=usb-0000:00:14.0-1.4/input0
# S: Sysfs=/devices/pci0000:00/0000:00:14.0/usb1/1-1/1-1.4/1-1.4:1.0/0003:045E:07CD.0012/input/input89
# U: Uniq=
# H: Handlers=mouse1 event6 
# B: PROP=5
# B: EV=1b
# B: KEY=e520 10000 0 0 0 0
# B: ABS=260800000000003
# B: MSC=20

# ORIENTATION AND AXIS MAJOR AND MINOR SEEM TO DEEL WITH HOW THE FINGER THAT IS CURRNETLY TOUCHING THE SCREENIS ORIENTED ON THE SCREEE, BELIVE ORIENTATION FIRES WHEN AXIS MAJOER BECOES LAEREE OR EBECOMES SMALLER THAN AXIS MINOR WBUT i HAVENT TESTED IT.
def main():
    gesture_sources = [["TOUCHPAD", [], TOUCHPAD_CALIBRATION], ["TOUCHSCREEN", [], TOUCHSCREEN_CALIBRATION]]
    mice_items = subprocess.getoutput("cat /proc/bus/input/devices | grep -iEB 2 mouse").split("--")
    mice_items[0] = "\n"+ mice_items[0]
    for gesture_source in gesture_sources:
        for i in mice_items:
            item = i.split("\n")
            dev_path = item[1].split("=")[1]
            b = subprocess.getoutput(" udevadm test-builtin input_id" + " " + dev_path + f"| grep -c {gesture_source[0]}")[-1]
            if int(b):
                device_event_name = item[3].split("=")[1].split(" ")[0]
                gesture_source[1].append(device_event_name)
                threading.Thread(target=test, args=[device_event_name, gesture_source[2], gesture_source[0].lower()]).start() #change here to use evemu-record
        print(f"Handlers for " + gesture_source[0] + f": {gesture_source[1]}")
    return 1;

def test(device_event_name, factor, dev):
    #make sure to start with a single finger when the base re-attaches because slot and tracking id won't fire before position
    status_dict = {"0":{"x_updated": 0, "y_updated": 0}, "1":{"x_updated": 0, "y_updated": 0}, "2": {"x_updated": 0, "y_updated": 0}, "3":{"x_updated": 0, "y_updated": 0}, "4": {"x_updated": 0, "y_updated": 0}} #when the touchpad is restarted issues arise because (ABS_MT_TRACKING_ID), isn't called before x or y , this solve
    slot = "0"
    update = False

    # queue and worker
    q = queue.Queue()
    w = Worker(q, all_gestures[dev])
    w.start()

    # orientation, emplementing x and y swap takes a bit more of work
    orientation = subprocess.getoutput("orientation");
    #print(orientation);
    orientation_y = -1 if("inverted" == orientation or "right" == orientation) else 1;
    orientation_x = -1 if("inverted" == orientation or "left" == orientation) else 1;
    
    swap_x_y = True if("right" == orientation or "left" == orientation) else False;
    #print(swap_x_y)
    cmd = subprocess.Popen(["stdbuf", "-oL", "--","evtest",f"/dev/input/{device_event_name}"], stdout=subprocess.PIPE, bufsize=1, universal_newlines=True)
    for line in cmd.stdout:
        # implement debouncing and switching from one to another

        # removes startup printing
        #print(status_dict)
        line_arr = line.split()
        #sys.stderr.write(str(line_arr))
        #sys.stderr.write("\n")
        print(f"line_array : {line_arr}")
        if (len(line_arr) < 2 or line_arr[1] != "time"):
            continue

        # get time,state, and event
        time = line_arr[2][:-1]
        state, event =  line_arr[-1],line_arr[-3] # for evemu-record, (time)item 87.194577 on index 1, (state)item 0 on index 9,  (event) item ABS_MT_TRACKING_ID on index 8

        if "(ABS_MT_TRACKING_ID)," == event:
            if state == "-1":
                try:
                    del status_dict[slot]
                except:
                    del status_dict[slot]

                #notify worker to flush queue after finger is removed
                q.put({"type": "finger_remove", "removed_slot": slot,"time": time })
                slot = "-1";
                #print(status_dict)
            else:
                if(slot == "-1"):
                    slot = "0"
                else:
                    slot = slot
                status_dict[slot] = {"x_updated": 0, "y_updated": 0}

                # debounce worker when finger is added
                # q.put({"type": "debounce"})
                #q.put({"type": "gesture_end", "time": time})


        if "(ABS_MT_SLOT)," == event:
            slot = state
            if slot not in status_dict:
                status_dict[slot] = {"x_updated": 0, "y_updated": 0}
        print("")
        print(f'slot != "-1", {slot} != "-1", {slot != "-1"}')
        print(f"status dict: {status_dict}")
        print("")
        if "(ABS_MT_POSITION_X)," == event:
            if (slot != "-1"):
                if(swap_x_y):
                    status_dict[slot]["y"] = float(state) / factor * orientation_y;
                    status_dict[slot]["y_updated"] += 1;
                else: 
                    status_dict[slot]["x"] = float(state) / factor * orientation_x;
                    status_dict[slot]["x_updated"] += 1;
                update = True;

        if "(ABS_MT_POSITION_Y)," == event:
            if (slot != "-1"):
                if(swap_x_y):
                    status_dict[slot]["x"] = float(state) / factor * orientation_x;
                    status_dict[slot]["x_updated"] += 1;
                else:
                    status_dict[slot]["y"] = float(state) / factor * orientation_y;
                    status_dict[slot]["y_updated"] += 1;
                update = True;

        # if "(ABS_X)," == event:
        #     x1 = int(state)
        #     update = True
        #
        # if "(ABS_Y)," == event:
        #     y1 = int(state)
        #     update = True

        if event == "--------------" or event == "(MSC_TIMESTAMP),":
            continue
        print("")
        print(f"update: {update}")
        print(f"slot: {slot}")
        print(f"status_dict before end: {status_dict}")    
        print(f"status before end: time = {time}, state = {state}, event = {event}")
        print("")

        if update:
            if status_dict[slot]["x_updated"] < 1 or status_dict[slot]["y_updated"] <  1:
                update = False
                continue

            x = status_dict[slot]["x"];
            y = status_dict[slot]["y"];
            finger_type = "";

            if ("objs" not in status_dict[slot]):
                status_dict[slot]["objs"] = True; # a way to call finger start the firt time a find is pressend down
                finger_type = "finger_start";
            else:
                finger_type = "finger_update";

            update = False;

            q.put({"type": finger_type, "slot": slot, "time": time, slot: {"x" :x , "y" : y} }); #remember that these x,y have  been scaled down for touchscreen so that the gui can be seen
            
        print(f"status_dict at end: {status_dict}")    
        print(f"time = {time}, state = {state}, event = {event}")
        print("")
if __name__ == "__main__":
    import sys
    # if call comes with arguments, pass only the first one. if it doesn't, start normal orientation operation
    # maybe implement builtin daemonization
    if len(sys.argv) > 1:
        DEBUG=1 if sys.argv[1].lower() == "debug" else 0;
        TYPE=sys.argv[2:];
        main()
    else:
        subprocess.Popen(["daemonize", sys.argv[0], "execute"])



